<?xml version="1.0" encoding="UTF-8"?><record_update sys_domain="global" table="sys_script">
    <sys_script action="INSERT_OR_UPDATE">
        <abort_action>false</abort_action>
        <access>package_private</access>
        <action_delete>false</action_delete>
        <action_insert>true</action_insert>
        <action_query>false</action_query>
        <action_update>true</action_update>
        <active>true</active>
        <add_message>false</add_message>
        <advanced>true</advanced>
        <change_fields>false</change_fields>
        <client_callable>false</client_callable>
        <collection>x_153465_discovert_tasker_schedule</collection>
        <condition/>
        <description/>
        <execute_function>false</execute_function>
        <filter_condition table="x_153465_discovert_tasker_schedule">repeat_type!=^EQ<item endquery="false" field="repeat_type" goto="false" newquery="false" operator="!=" or="false" value=""/>
            <item endquery="true" field="" goto="false" newquery="false" operator="=" or="false" value=""/>
        </filter_condition>
        <is_rest>false</is_rest>
        <message/>
        <name>Task Schedule - onChange</name>
        <order>30</order>
        <priority>100</priority>
        <rest_method/>
        <rest_method_text/>
        <rest_service/>
        <rest_service_text/>
        <rest_variables/>
        <role_conditions/>
        <script><![CDATA[(function executeRule(current, previous /*null when async*/) {

	var today_date = new GlideDate();
	var start_date = new GlideDate();
	start_date.setValue(current.start_date);
	var end_by_date = new GlideDate();
	end_by_date.setValue(current.repeat_until);

	// if the next run date changes, then the schedule was run. 
	// update the occurrence count.  Can't log schedule from here b/c we don't have the process instance
	if (current.last_run != previous.last_run){
		current.occurence_count++;
	}
	
	if (current.repeat_until_type.toString() == 'no_end_date') {
		current.schedule_complete_flag = false;
	}
	
	if (current.repeat_until_type.toString() == 'end_by') {
		// if the start date is greater than the end date, don't allow the user to save and raise an error message
	 	if(start_date.compareTo(end_by_date) > 0) {
			current.setAbortAction(true);
			gs.addErrorMessage(gs.getMessage("Repeat Until Date cannot be before event Start Date."));
			return;
		}
		// if the end date has passed, set the complete flag to true and prompt the user
		if(today_date.compareTo(end_by_date) > 0) {
			current.schedule_complete_flag = true;
			gs.addInfoMessage(gs.getMessage("The 'End by' date is in the past, the 'Set complete flag' has been turned on.  To restart the schedule, increase Occurance count, increase the 'Repeat until date', or create a new schedule"));
		}
		//  the end date is in the future, make sure the complete flag is false
		else{
			current.schedule_complete_flag = false;
		}	
	}
	// if the number of occurances have been reached set the complete flag to true and prompt the user
	if (current.repeat_until_type.toString() == 'end_after') {
		if (current.occurence_count >= current.occurrences){
			current.schedule_complete_flag = true;
			gs.addInfoMessage(gs.getMessage("The 'End after' count has been reached, the 'Set complete flag' has been turned on.  To restart the schedule, increase Occurance count, increase the 'Repeat until date', or create a new schedule."));
		}
		// if the number of occurances have not been reached make sure the complete flag is false
		else { 
			current.schedule_complete_flag = false;
		}
	}
	
	// set next_run_Date needs to be updated
	var tsScript = new TaskerSchedulerScript();
	var gdtNextRunDate = new GlideDate();
	gdtNextRunDate.setValue(tsScript.getNextRunDate(current));					
	current.next_run_date = gdtNextRunDate.getValue();

	current.repeat_description = tsScript.getRepeatDescription(current.repeat_type.toString(), current.repeat_count, current.start_date, current.days_of_week.toString(), current.monthly_type.toString(), current.yearly_type.toString(), null);

	// if next run date is after end date set the complete flag to true and prompt the user
	if ((current.repeat_until_type.toString() == 'end_by')) {
		if((end_by_date.compareTo(gdtNextRunDate) < 0)){
			current.schedule_complete_flag = true;
			gs.addInfoMessage(gs.getMessage("The 'Next run date' is after the 'End by' date, the 'Set complete flag' has been set.  To restart the schedule, increase Occurance count, increase the 'Repeat until date', or create a new schedule."));
	}}
	// at the end of the update, if the schedule is complete, set the 'Next run date to null to keep the schedule from running anymore.
	if(current.schedule_complete_flag == true){
		current.next_run_date = null;
	}
	
	})(current, previous);]]></script>
        <sys_class_name>sys_script</sys_class_name>
        <sys_created_by>rjoy</sys_created_by>
        <sys_created_on>2018-05-23 19:28:55</sys_created_on>
        <sys_customer_update>false</sys_customer_update>
        <sys_domain>global</sys_domain>
        <sys_domain_path>/</sys_domain_path>
        <sys_id>3f75e3bcdb1253403a8d6be3ca961976</sys_id>
        <sys_mod_count>47</sys_mod_count>
        <sys_name>Task Schedule - onChange</sys_name>
        <sys_overrides/>
        <sys_package display_value="Tasker" source="x_153465_discovert">c6b1162d4fc10300303dc3818110c7b1</sys_package>
        <sys_policy>protected</sys_policy>
        <sys_replace_on_upgrade>false</sys_replace_on_upgrade>
        <sys_scope display_value="Tasker">c6b1162d4fc10300303dc3818110c7b1</sys_scope>
        <sys_update_name>sys_script_3f75e3bcdb1253403a8d6be3ca961976</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2018-08-02 20:45:03</sys_updated_on>
        <template/>
        <when>before</when>
    </sys_script>
    <sys_translated_text action="delete_multiple" query="documentkey=3f75e3bcdb1253403a8d6be3ca961976"/>
</record_update>
