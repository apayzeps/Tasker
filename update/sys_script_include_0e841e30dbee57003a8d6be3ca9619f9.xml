<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>package_private</access>
        <active>true</active>
        <api_name>x_153465_discovert.TaskerSchedulerScript</api_name>
        <client_callable>true</client_callable>
        <description/>
        <name>TaskerSchedulerScript</name>
        <script><![CDATA[var TaskerSchedulerScript = Class.create();
TaskerSchedulerScript.prototype = Object.extendsObject(global.AbstractAjaxProcessor, {
	
	ajaxFunction_scheduleTime: function() {
		return this.getRepeatDescription(
		this.getParameter('sysparm_repeat_type'),
		this.getParameter('sysparm_repeat_count'),
		this.getParameter('sysparm_start_date'),
		this.getParameter('sysparm_days_of_week'),
		this.getParameter('sysparm_monthly_type'),
		this.getParameter('sysparm_yearly_type'),
		this.getParameter('sysparm_month'));
	},
	
	// 	ajaxFunction_scheduleDateTime: function() {
		// 		var sdt = new ScheduleDateTime(this.getParameter('sysparm_dt_tm'));
		// 		if (this.getParameter('sysparm_include_z_format') == 'false')
		// 			sdt.setIncludeZFormat(false);
		// 		return sdt.convertTimeZone(this.getParameter('sysparm_current_timezone'),this.getParameter('sysparm_new_timezone'));
		// 	},
		
		getRepeatDescription : function(type, count, start, days, monthly, yearly, month) {
			var answer;
			var answerEndSingular = '';
			var answerEndPlural = '';
			var startDate = GlideDateTime(start);
			switch (type) {
				case 'daily':
				answerEndSingular = 'day';
				answerEndPlural = 'days';
				break;
				case 'weekly':
				answerEndSingular = 'week';
				answerEndPlural = 'weeks';
				var startDOW = startDate.getDayOfWeekUTC();
				// if the dow selected in the dropdown changes, but the start date doesn't
				// this will force the date to be shown to be the dow selected, not based on startdate
				if (startDOW != days){
					startDOW = days;
				}
				answerEndSingular = answerEndSingular + ' on ' + this.getDayOfWeekText(startDOW);
				answerEndPlural = answerEndPlural + ' on ' + this.getDayOfWeekText(startDOW);
				break;
				case 'monthly':
				answerEndSingular = 'month';
				answerEndPlural = 'months';
				if(monthly == 'dom'){
					answerEndSingular = answerEndSingular + ' on day ' + startDate.getDayOfMonthUTC();
					answerEndPlural = answerEndPlural + ' on day ' + startDate.getDayOfMonthUTC();
				}
				else{
					answerEndSingular = answerEndSingular + ' on the ' + this.getDayOfWeekOfMonth(start);
					answerEndPlural = answerEndPlural + ' on the ' + this.getDayOfWeekOfMonth(start);
				}
				break;
				case 'yearly':
				answerEndSingular = 'year';
				answerEndPlural = 'years';
				var moyInt = startDate.getMonthUTC();
				if(yearly=='doy'){
					answerEndSingular = answerEndSingular + ' on ' + this.getMonthText(moyInt) + ' ' +  startDate.getDayOfMonthUTC();
					answerEndPlural = answerEndPlural + ' on ' + this.getMonthText(moyInt) + ' ' +  startDate.getDayOfMonthUTC();
					
				}
				else {
					answerEndSingular = answerEndSingular + ' on the ' + this.getDayOfWeekOfMonth(start) + ' of ' +  this.getMonthText(moyInt);
					answerEndPlural = answerEndPlural + ' on the ' + this.getDayOfWeekOfMonth(start) + ' of ' +  this.getMonthText(moyInt);
				}
				break;
				default:
				answer = 'Error, invalid type - ' + type.toString() + ' ' + count.toString() + ' ' + start.toString() + ' ' + days.toString() + ' ' + monthly.toString() + ' ' + yearly.toString() + ' ' + month.toString();
			}
			
			if (count<=0) {
				answer = '<b>Repeat every</b> must be specified';
			}
			else if(count==1){
				answer = 'Every ' + answerEndSingular;
			}
			else {
				answer = 'Every ' + count + ' ' + answerEndPlural;
			}
			return answer;
		},
		
		getDayOfWeekOfMonth : function(inputDate) {
			var varDate = GlideDateTime(inputDate);
			var dom = varDate.getDayOfMonthUTC();
			var dow = varDate.getDayOfWeekUTC();
			var dowText = this.getDayOfWeekText(dow);
			var sWeekNum = this.getWeekOfMonth(dom, dow);
			
			// number from dow starts at 1, arrays start at zero.  subtract one
			return sWeekNum + ' ' + dowText;
		},

		getWeekOfMonth : function(dom, dow) {
			var sWeekNum;
			switch (true) {
				case (dom<=dow): sWeekNum = 'First'; break;
				case ((dom-7)<=0): sWeekNum = 'First'; break;
				case ((dom-14)<=0): sWeekNum = 'Second'; break;
				case ((dom-21)<=0): sWeekNum = 'Third'; break;
				case ((dom-28)<=0): sWeekNum = 'Fourth'; break;
				default: sWeekNum = 'Last';
			}
			// number from dow starts at 1, arrays start at zero.  subtract one
			return sWeekNum;
		},
	
		getDayOfWeekText: function(dowInt) {
			var aDOW = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
			// number from dow starts at 1, arrays start at zero.  subtract one
			return aDOW[dowInt-1];
		},
		
		getMonthText: function(moyInt) {
			var aMOY = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
			// number from dow starts at 1, arrays start at zero.  subtract one
			return aMOY[moyInt-1];
		},

		getLastDayOfMonth: function(moyInt) {
			var aMOY = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
			// number from dow starts at 1, arrays start at zero.  subtract one
			return aMOY[moyInt-1];
		},
	
		ajaxFunction_getDayOfWeek: function() {
			var inputDate = this.getParameter('sysparm_start_date');
			var varDate = GlideDateTime(inputDate);
			var dow = varDate.getDayOfWeekUTC();
			return dow;
		},
		
		// RAJ 2018-07-19 - STRY0012696 - added this to remove the getReference calls
		ajaxFunction_getProcessName: function() {
			var strTaskerProcess = this.getParameter('sysparm_Tasker_Process');
			
			var grTaskerProcessTemplate = new GlideRecord('x_153465_discovert_discover_routing_template');
			grTaskerProcessTemplate.get(strTaskerProcess);
			return grTaskerProcessTemplate.template_name;
		},
		
		getNextRunDate : function(taskerSchedule) {
			var gDate = new GlideDateTime();
			var taskerSchedule_Start = new GlideDateTime(taskerSchedule.start_date);
			var today_date_only = gDate.getDate();
			if (taskerSchedule.schedule_complete_flag){
				gs.addErrorMessage('Tasker Schedule is complete.  Uncheck the complete flag and change the "Repeat until" type to "no end", extend the end date, or increase the number of occurrences to extend the schedule.');
				return null;
			}
			if(today_date_only <= taskerSchedule.start_date){
				// use last run if it has been run before
				// use start_date if not
				// if the start date was updated to be later than last run, we may want to reopen
				gDate.setValue(taskerSchedule.start_date);
				return gDate;
			}
			var last_run_date;
			if(taskerSchedule.last_run > 0){
				last_run_date = GlideDateTime(taskerSchedule.last_run).getDate();	
			}
			var daysApart = GlideDateTime.subtract(taskerSchedule_Start, today_date_only);		
			
			var dayDiff;
			var days_to_add;

			// get start date values
			var start_dom = taskerSchedule_Start.getDayOfMonthUTC();
			var start_mo = taskerSchedule_Start.getMonthUTC();
			var start_yr = taskerSchedule_Start.getYearUTC();
			var start_dow = taskerSchedule_Start.getDayOfWeekUTC();
			var start_wom = this.getWeekOfMonth(start_dom, start_dow);

			// get current date values
			var cur_dom = gDate.getDayOfMonthUTC();
			var cur_mo = gDate.getMonthUTC();
			var cur_yr = gDate.getYearUTC();
			var cur_dow = gDate.getDayOfWeekUTC();
			var cur_wom = this.getWeekOfMonth(cur_dom, cur_dow);
			var init_next_run_Date;
			var next_run_dow;
			var last_day_of_mo;
			var last_day_dow;
			var last_dom;
			var mos_until_next_scheudled_run;
			// from here down, use the last_run_date and the schedule to determine next_run_date
			switch (taskerSchedule.repeat_type.toString()) {
				case 'daily':
				// on a daily run, calculate the pattern back to the start date
				// take a mod based on the difference between current date and the pattern
				// add the Mod to the current date to get the next run
				// we patterned off of outlook.  Outlook doesn't look at LAST_RUN. Outlook calculates based on pattern and start date
				dayDiff = parseInt(daysApart.getDayPart()) % parseInt(taskerSchedule.repeat_count);
				days_to_add = parseInt(taskerSchedule.repeat_count) - dayDiff;					
				gDate.addDaysLocalTime(parseInt(days_to_add));
				// if already run today, AND THE PATTERN WAS SUPPOSED TO RUN TODAY (current next run being returned is today)
				// second part accounts for it running today and the patter changing or it running today, but the pattern was off
				if(last_run_date > 0){
					if((last_run_date.compareTo(today_date_only) >= 0) && (gDate.getDate() == today_date_only))  {
						gDate.addDaysLocalTime(parseInt(taskerSchedule.repeat_count));
					}
				}
				return gDate;
				case 'weekly':
				// NOTE: if start date is today, it might not get run until tomorrow
				// TODO: we may want to add a "force run" flag to force it to run today.
				// take start date, subract today's date divide by 7 times the number of weeks
				// take the remainder and add it to today's date and that should be your next run date
				dayDiff = parseInt(daysApart.getDayPart()) % (7*parseInt(taskerSchedule.repeat_count));
				days_to_add = (7*parseInt(taskerSchedule.repeat_count)) - dayDiff;
				gDate.addDaysLocalTime(parseInt(days_to_add));
				// if already run today, AND THE PATTERN WAS SUPPOSED TO RUN TODAY (current next run being returned is today)
				// second part accounts for it running today and the patter changing or it running today, but the pattern was off
					if(last_run_date > 0){
						if((last_run_date.compareTo(today_date_only) >= 0) && (gDate.getDate() == today_date_only))  {
							gDate.addDaysLocalTime((7*parseInt(taskerSchedule.repeat_count)));
						}
					}
				return gDate;
				case 'monthly':
				// get the day of the month from the start date
				// determine the start month and start year from the last run date
				// determine the current month and current year
				// get the months and years between start date using and current date
				// compute the total months between start and today
				// determine next run month by using the start date and the pattern against today's date
				var mo_diff;
				if (start_yr == cur_yr) {
					mo_diff = cur_mo - start_mo;
				} else {
					// subtract start year from current year, multiply by 12, add to this (current month - start month)
					// when start month is bigger than current month, 12 is added
					mo_diff = ((cur_yr - start_yr) * 12) + (cur_mo - start_mo);
				}
				// the Month difference has been calcualted, now compare the pattern to the Month difference to set next run date based on today's date
				// find the Mod, if it exists and subract from the pattern
				// if the last run was not on schedule, using the mod this will get it back on schedule
				var mos_since_last_scheudled_run = parseInt(mo_diff) % (parseInt(taskerSchedule.repeat_count));

				// if schedule is supposed to run this month
				// check the DOM and DOW and determine if it already ran or still needs to run
				// if still needs to run then, set the mo_until_run to 0 so it runs this month
				// otherwise, add the pattern to the current month to push out
				if ((mos_since_last_scheudled_run==0)
					&& (taskerSchedule.monthly_type == 'dom')
					&& (cur_dom <= start_dom) 
					){
					mos_until_next_scheudled_run = 0;
				} else if ( (mos_since_last_scheudled_run==0)
						&& (taskerSchedule.monthly_type == 'nth') 
						&& (cur_wom < start_wom)) {
					mos_until_next_scheudled_run = 0;
				} else if( (mos_since_last_scheudled_run==0)
						&& (taskerSchedule.monthly_type == 'nth') 
						&& (cur_wom == start_wom) && (cur_dow <= start_dow)){
					mos_until_next_scheudled_run = 0;	
				}  else
					mos_until_next_scheudled_run = parseInt(taskerSchedule.repeat_count) - parseInt(mos_since_last_scheudled_run);
				
				// account for it having run already this month
				if ((mos_since_last_scheudled_run==0)){
					var start_of_last_run_mo = new GlideDateTime(this.padStart(parseInt(cur_mo),0, 2) + '-' + this.padStart(1,0, 2) + '-' + cur_yr);	
					if(last_run_date > 0){
						if (last_run_date.compareTo(start_of_last_run_mo) >= 0) { 
							mos_until_next_scheudled_run = parseInt(taskerSchedule.repeat_count);	
						}
					}
				}
					
				// now we have the # of months since the last scheduled run.
				// using this, we subtract that from the schedule and that is the number of months until the next run
				// add this many months to the current month and we are golden!
				var mo_to_run = 0;
				var yr_to_run = cur_yr;
				if (parseInt(mos_until_next_scheudled_run) + parseInt(cur_mo) > 12 ){
					// if we are going into another year, we need to add to the year
					mo_to_run = (parseInt(mos_until_next_scheudled_run) + parseInt(cur_mo)) % 12;
					yr_to_run = cur_yr + parseInt((parseInt(mos_until_next_scheudled_run) + parseInt(cur_mo)) / 12);
				} else {
					// add months to current month, leave year alone
					mo_to_run = cur_mo + mos_until_next_scheudled_run;
					yr_to_run = cur_yr;
				}
					
				var last_day_of_Month = this.getLastDayOfMonth(parseInt(mo_to_run));
				var day_to_run = 0;
				if (taskerSchedule.monthly_type == 'dom'){
					// set day_to_run equal to start dom for montly type 'Day of the Month' as it will always run on the same day
					if(start_dom > last_day_of_Month)
						day_to_run = last_day_of_Month;
					else
						day_to_run = start_dom;
				} else if (taskerSchedule.monthly_type == 'nth') {
					// when the "next run month is determined, find the right date based on dom or dow
					if(start_dom > last_day_of_Month)
						init_next_run_Date = new GlideDateTime(this.padStart(mo_to_run,0, 2) + '-' + this.padStart(last_day_of_Month,0, 2) + '-' + yr_to_run);
					else
						init_next_run_Date = new GlideDateTime(this.padStart(mo_to_run,0, 2) + '-' + this.padStart(start_dom,0, 2) + '-' + yr_to_run);					
					// start with the month determined above
					// add 7 days for each day of the week unless "first or last"
					// for example, if text says "third week" start on day 21 and see what day of the week it is 
					// Day 21 is the first day that would be the third mon,tue,wed... for that month
					next_run_dow = init_next_run_Date.getDayOfWeekUTC();
					
					// note, both start in the same wom
					// we need to shift the date to stay in the right wom, and move to the correct dow
					switch (start_wom) {
						case 'First': 
							if (next_run_dow > start_dow){ 
								day_to_run = start_dom - (next_run_dow - start_dow);
							} 
							if (start_dow > next_run_dow){ 
								day_to_run = start_dom + (start_dow - next_run_dow);
								if(day_to_run > 7){
									day_to_run = day_to_run - 7;
								}
							}
							break;
						case 'Second': 
							if (next_run_dow > start_dow){ 
								day_to_run = start_dom - (next_run_dow - start_dow);
								if(day_to_run < 8){
									day_to_run = day_to_run + 7;
								}
							} 
							if (start_dow > next_run_dow){ 
								day_to_run = start_dom + (start_dow - next_run_dow);
								if(day_to_run > 14){
									day_to_run = day_to_run - 7;
								}
							}
							break;
						case 'Third': 
							if (next_run_dow > start_dow){ 
								day_to_run = start_dom - (next_run_dow - start_dow);
								if(day_to_run < 15){
									day_to_run = day_to_run + 7;
								}
							} 
							if (start_dow > next_run_dow){ 
								day_to_run = start_dom + (start_dow - next_run_dow);
								if(day_to_run > 21){
									day_to_run = day_to_run - 7;
								}
							}
							break;
						case 'Fourth': 
							if (next_run_dow > start_dow){ 
								day_to_run = start_dom - (next_run_dow - start_dow);
								if(day_to_run < 22){
									day_to_run = day_to_run + 7;
								}
							} 
							if (start_dow > next_run_dow){ 
								day_to_run = start_dom + (start_dow - next_run_dow);
								if(day_to_run > 28){
									day_to_run = day_to_run - 7;
								}
							}
							break;
						default: 
							// last is a little differnt b/c months have different numbers of days
							// for last, we will go to the first day of the following month, determine its day of week
							// then subtract the right number to get to the day of the week we want.
							
							// go to first day of month after next run
							// add one to month
							if (mo_to_run == 12){
								last_day_of_mo = new GlideDateTime(this.padStart(1,0, 2) + '-' + this.padStart(1,0, 2) + '-' + parseInt(yr_to_run)+1);
							} else {
								last_day_of_mo = new GlideDateTime(this.padStart(parseInt(mo_to_run)+1,0, 2) + '-' + this.padStart(1,0, 2) + '-' + yr_to_run);								
							}
							// above sets to first day of next month, this sets to last day of this month
							last_day_of_mo.addDaysUTC(-1);
							last_day_dow = last_day_of_mo.getDayOfWeekUTC();
							last_dom = last_day_of_mo.getDayOfMonthUTC();
							switch (true) {
								case (last_day_dow > start_dow):
									day_to_run = last_dom - (last_day_dow - start_dow); 
									break;
								case (last_day_dow == start_dow):
									// should stay same
									day_to_run = last_dom;
									break;
								case (last_day_dow < start_dow):
									day_to_run = last_dom + (start_dow - last_day_dow) - 7;
									break;
							}
							break;
					}					
				}
					
				gDate = new GlideDateTime(this.padStart(mo_to_run,0, 2) + '-' + this.padStart(day_to_run,0, 2) + '-' + yr_to_run);
				return gDate.getDate();
				case 'yearly':
				// get the day of the month from the start date
				// get the years between start date and current date
				// compute the total years between start and today
				// determine next run year by using the start date and the pattern against today's date
				var yr_diff = cur_yr - start_yr;
				// the year difference has been calcualted, now compare the pattern to the year difference to set next run date based on today's date
				// find the Mod, if it exists and subract from the pattern
				var yrs_since_last_scheudled_run = parseInt(yr_diff) % (parseInt(taskerSchedule.repeat_count));
				// now we have the # of years since the last scheduled run.
				var yrs_until_next_scheudled_run = 0;	
				// if schedule is supposed to run this year
				// check if already run this year or still needs to run
				// if still needs to run then, set the yrs_until_next_scheudled_run to 0 so it runs this year
				// otherwise, add the pattern to the current year to push out
				if ((yrs_since_last_scheudled_run==0)
					&& (cur_mo <= start_mo)
					){
					yrs_until_next_scheudled_run = 0;
				} else if ((yrs_since_last_scheudled_run==0)
					&& (taskerSchedule.yearly_type == 'doy')
					&& (cur_mo == start_mo)
					&& (cur_dom <= start_dom)
					){
					yrs_until_next_scheudled_run = 0;
				} else if ((yrs_until_next_scheudled_run==0)
						&& (taskerSchedule.yearly_type == 'float')  
						&& (cur_mo == start_mo)						   
						&& (cur_wom < start_wom)) {
					yrs_until_next_scheudled_run = 0;
				} else if ((yrs_until_next_scheudled_run==0)
						&& (taskerSchedule.yearly_type == 'float')  
						&& (cur_mo == start_mo)						   
						&& (cur_wom == start_wom) && (cur_dow <= start_dow)){
					yrs_until_next_scheudled_run = 0;	
				}  else
					yrs_until_next_scheudled_run = parseInt(taskerSchedule.repeat_count) - parseInt(yrs_since_last_scheudled_run);	

				// account for it having run already this year
				if ((yrs_since_last_scheudled_run==0)){
					var start_of_last_run_yr = new GlideDateTime(this.padStart(1,0, 2) + '-' + this.padStart(1,0, 2) + '-' + cur_yr);	
					if(last_run_date > 0){
						if (last_run_date.compareTo(start_of_last_run_yr) >= 0) { 
							yrs_since_last_scheudled_run = parseInt(taskerSchedule.repeat_count);	
						}
					}
				}
					
				// add this many months to the current month and we are golden!
				mo_to_run = start_mo;
				yr_to_run = cur_yr + yrs_until_next_scheudled_run;

				last_day_of_Month = this.getLastDayOfMonth(parseInt(mo_to_run));
				day_to_run = 0;
				
				if (taskerSchedule.yearly_type == 'doy'){
					// set day_to_run equal to start dom for montly type 'Day of the Month' as it will always run on the same day
					if(start_dom > last_day_of_Month)
						day_to_run = last_day_of_Month;
					else
						day_to_run = start_dom;
				} else if (taskerSchedule.yearly_type == 'float') {
					// when the "next run month is determined, find the right date based on dom or dow
					if(start_dom > last_day_of_Month)
						init_next_run_Date = new GlideDateTime(this.padStart(mo_to_run,0, 2) + '-' + this.padStart(last_day_of_Month,0, 2) + '-' + yr_to_run);
					else
						init_next_run_Date = new GlideDateTime(this.padStart(mo_to_run,0, 2) + '-' + this.padStart(start_dom,0, 2) + '-' + yr_to_run);					
					// start with the month determined above
					// add 7 days for each day of the week unless "first or last"
					// for example, if text says "third week" start on day 21 and see what day of the week it is 
					// Day 21 is the first day that would be the third mon,tue,wed... for that month
					next_run_dow = init_next_run_Date.getDayOfWeekUTC();
					
					// note, both start in the same wom
					// we need to shift the date to stay in the right wom, and move to the correct dow
					switch (start_wom) {
						case 'First': 
							if (next_run_dow > start_dow){ 
								day_to_run = start_dom - (next_run_dow - start_dow);
							} 
							if (start_dow > next_run_dow){ 
								day_to_run = start_dom + (start_dow - next_run_dow);
								if(day_to_run > 7){
									day_to_run = day_to_run - 7;
								}
							}
							break;
						case 'Second': 
							if (next_run_dow > start_dow){ 
								day_to_run = start_dom - (next_run_dow - start_dow);
								if(day_to_run < 8){
									day_to_run = day_to_run + 7;
								}
							} 
							if (start_dow > next_run_dow){ 
								day_to_run = start_dom + (start_dow - next_run_dow);
								if(day_to_run > 14){
									day_to_run = day_to_run - 7;
								}
							}
							break;
						case 'Third': 
							if (next_run_dow > start_dow){ 
								day_to_run = start_dom - (next_run_dow - start_dow);
								if(day_to_run < 15){
									day_to_run = day_to_run + 7;
								}
							} 
							if (start_dow > next_run_dow){ 
								day_to_run = start_dom + (start_dow - next_run_dow);
								if(day_to_run > 21){
									day_to_run = day_to_run - 7;
								}
							}
							break;
						case 'Fourth': 
							if (next_run_dow > start_dow){ 
								day_to_run = start_dom - (next_run_dow - start_dow);
								if(day_to_run < 22){
									day_to_run = day_to_run + 7;
								}
							} 
							if (start_dow > next_run_dow){ 
								day_to_run = start_dom + (start_dow - next_run_dow);
								if(day_to_run > 28){
									day_to_run = day_to_run - 7;
								}
							}
							break;
						default: 
							// last is a little differnt b/c months have different numbers of days
							// for last, we will go to the first day of the following month, determine its day of week
							// then subtract the right number to get to the day of the week we want.
							
							// go to first day of month after next run
							// add one to month
							if (mo_to_run == 12){
								last_day_of_mo = new GlideDateTime(this.padStart(1,0, 2) + '-' + this.padStart(1,0, 2) + '-' + parseInt(yr_to_run)+1);
							} else {
								last_day_of_mo = new GlideDateTime(this.padStart(parseInt(mo_to_run)+1,0, 2) + '-' + this.padStart(1,0, 2) + '-' + yr_to_run);								
							}
							// above sets to first day of next month, this sets to last day of this month
							last_day_of_mo.addDaysUTC(-1);
							last_day_dow = last_day_of_mo.getDayOfWeekUTC();
							last_dom = last_day_of_mo.getDayOfMonthUTC();
							switch (true) {
								case (last_day_dow > start_dow):
									day_to_run = last_dom - (last_day_dow - start_dow); 
									break;
								case (last_day_dow == start_dow):
									// should stay same
									day_to_run = last_dom;
									break;
								case (last_day_dow < start_dow):
									day_to_run = last_dom + (start_dow - last_day_dow) - 7;
									break;
							}
							break;
					}					
				}
				gDate = new GlideDateTime(this.padStart(mo_to_run,0, 2) + '-' + this.padStart(day_to_run,0, 2) + '-' + yr_to_run);
				return gDate.getDate();
				default:
					gs.addErrorMessage('Error: Unknown repeate type selected: ' + taskerSchedule.repeat_type );
			}
			
		},
	
		padStart : function(input, character, len) {
			var output = input + "";
			while (output.length < len){
				output = character + output;
			}
			return output;
		},
	
		type: 'TaskerSchedulerScript'
	});]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2018-06-05 00:02:15</sys_created_on>
        <sys_customer_update>false</sys_customer_update>
        <sys_id>0e841e30dbee57003a8d6be3ca9619f9</sys_id>
        <sys_mod_count>210</sys_mod_count>
        <sys_name>TaskerSchedulerScript</sys_name>
        <sys_package display_value="Tasker" source="x_153465_discovert">c6b1162d4fc10300303dc3818110c7b1</sys_package>
        <sys_policy>protected</sys_policy>
        <sys_replace_on_upgrade>false</sys_replace_on_upgrade>
        <sys_scope display_value="Tasker">c6b1162d4fc10300303dc3818110c7b1</sys_scope>
        <sys_update_name>sys_script_include_0e841e30dbee57003a8d6be3ca9619f9</sys_update_name>
        <sys_updated_by>aalzyoud</sys_updated_by>
        <sys_updated_on>2019-03-22 14:57:22</sys_updated_on>
    </sys_script_include>
</record_update>
